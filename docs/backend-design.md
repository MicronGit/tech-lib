# ‚ö° „Éê„ÉÉ„ÇØ„Ç®„É≥„ÉâË®≠Ë®àÊõ∏ - ÊäÄË°ìÊõ∏ÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†

> Go + Gin „Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ„Å´„Çà„ÇãÈ´òÊÄßËÉΩRESTful API„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£Ë®≠Ë®à

## üìã Ë®≠Ë®àÊ¶ÇË¶Å

### „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£„ÅÆÂü∫Êú¨ÊñπÈáù
- **„Éâ„É°„Ç§„É≥ÈßÜÂãïË®≠Ë®à**: „Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØ„Çí‰∏≠ÂøÉ„Å®„Åó„ÅüË®≠Ë®à
- **„ÇØ„É™„Éº„É≥„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£**: ‰æùÂ≠òÈñ¢‰øÇ„ÅÆÂà∂Âæ°„Å®‰øùÂÆàÊÄß„ÅÆÁ¢∫‰øù
- **APIÂÑ™ÂÖà**: RESTfulË®≠Ë®àÂéüÂâá„Å´Ê∫ñÊã†
- **„Çπ„Ç±„Éº„É©„Éì„É™„ÉÜ„Ç£**: Ê∞¥Âπ≥„ÉªÂûÇÁõ¥„Çπ„Ç±„Éº„É™„É≥„Ç∞ÂØæÂøú
- **ÂèØË¶≥Ê∏¨ÊÄß**: „É≠„Ç∞„Éª„É°„Éà„É™„ÇØ„Çπ„Éª„Éà„É¨„Éº„Ç∑„É≥„Ç∞Áµ±Âêà

### ÊäÄË°ì„Çπ„Çø„ÉÉ„ÇØË©≥Á¥∞
| ÊäÄË°ì | „Éê„Éº„Ç∏„Éß„É≥ | ÂΩπÂâ≤ | ÈÅ∏ÂÆöÁêÜÁî± |
|------|-----------|------|----------|
| Go | 1.23+ | Ë®ÄË™û | È´òÊÄßËÉΩ„ÄÅ‰∏¶Ë°åÂá¶ÁêÜ„ÄÅ„É°„É¢„É™ÂäπÁéá |
| Gin | 1.9+ | Web„Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ | ËªΩÈáè„ÄÅÈ´òÈÄü„ÄÅË±äÂØå„Å™„Éü„Éâ„É´„Ç¶„Çß„Ç¢ |
| GORM | 1.25+ | ORM | GoÊ®ôÊ∫ñ„ÄÅ„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥Ê©üËÉΩ |
| PostgreSQL | 15+ | „Éá„Éº„Çø„Éô„Éº„Çπ | ACIDÊ∫ñÊã†„ÄÅÊã°ÂºµÊÄß„ÄÅJSONÂØæÂøú |
| Redis | 7+ | „Ç≠„É£„ÉÉ„Ç∑„É• | È´òÈÄü„Ç¢„ÇØ„Çª„Çπ„ÄÅ„Çª„ÉÉ„Ç∑„Éß„É≥ÁÆ°ÁêÜ |
| Docker | 24+ | „Ç≥„É≥„ÉÜ„ÉäÂåñ | Áí∞Â¢É‰∏ÄË≤´ÊÄß„ÄÅ„Éá„Éó„É≠„Ç§Á∞°ÊòìÂåñ |

## üèóÔ∏è „Ç∑„Çπ„ÉÜ„É†„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£

### „É¨„Ç§„É§„Éº„Éâ „Ç¢„Éº„Ç≠„ÉÜ„ÇØ„ÉÅ„É£
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                API Layer                ‚îÇ  ‚Üê HTTP „Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ              Service Layer              ‚îÇ  ‚Üê „Éì„Ç∏„Éç„Çπ„É≠„Ç∏„ÉÉ„ÇØ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ            Repository Layer             ‚îÇ  ‚Üê „Éá„Éº„Çø„Ç¢„ÇØ„Çª„Çπ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ              Domain Layer               ‚îÇ  ‚Üê „Éâ„É°„Ç§„É≥„É¢„Éá„É´
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### „Éá„Ç£„É¨„ÇØ„Éà„É™ÊßãÈÄ†
```
backend/
‚îú‚îÄ‚îÄ üìÅ cmd/                    # „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Ç®„É≥„Éà„É™„Éº„Éù„Ç§„É≥„Éà
‚îÇ   ‚îî‚îÄ‚îÄ server/
‚îÇ       ‚îî‚îÄ‚îÄ main.go            # „Çµ„Éº„Éê„ÉºËµ∑Âãï„Çπ„ÇØ„É™„Éó„Éà
‚îú‚îÄ‚îÄ üìÅ internal/               # ÈùûÂÖ¨Èñã„Éë„ÉÉ„Ç±„Éº„Ç∏
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ api/                # APIÂ±§ÔºàHTTP „Éè„É≥„Éâ„É©„ÉºÔºâ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handlers/          # HTTP „Éè„É≥„Éâ„É©„Éº
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware/        # „Éü„Éâ„É´„Ç¶„Çß„Ç¢
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validators/        # „É™„ÇØ„Ç®„Çπ„ÉàÊ§úË®º
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ responses/         # „É¨„Çπ„Éù„É≥„ÇπÊßãÈÄ†
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ domain/             # „Éâ„É°„Ç§„É≥Â±§
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/          # „Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ repositories/      # „É™„Éù„Ç∏„Éà„É™„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/          # „Éâ„É°„Ç§„É≥„Çµ„Éº„Éì„Çπ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ errors/            # „Éâ„É°„Ç§„É≥„Ç®„É©„Éº
‚îÇ   ‚îú‚îÄ‚îÄ üìÅ infrastructure/     # „Ç§„É≥„Éï„É©Â±§
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ database/          # „Éá„Éº„Çø„Éô„Éº„ÇπË®≠ÂÆö
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cache/             # „Ç≠„É£„ÉÉ„Ç∑„É•ÂÆüË£Ö
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logger/            # „É≠„Ç∞ÂÆüË£Ö
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ config/            # Ë®≠ÂÆöÁÆ°ÁêÜ
‚îÇ   ‚îî‚îÄ‚îÄ üìÅ application/        # „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Â±§
‚îÇ       ‚îú‚îÄ‚îÄ services/          # „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥„Çµ„Éº„Éì„Çπ
‚îÇ       ‚îú‚îÄ‚îÄ dto/               # „Éá„Éº„ÇøËª¢ÈÄÅ„Ç™„Éñ„Ç∏„Çß„ÇØ„Éà
‚îÇ       ‚îî‚îÄ‚îÄ usecases/          # „É¶„Éº„Çπ„Ç±„Éº„Çπ
‚îú‚îÄ‚îÄ üìÅ pkg/                    # ÂÖ¨Èñã„Éë„ÉÉ„Ç±„Éº„Ç∏
‚îÇ   ‚îú‚îÄ‚îÄ utils/                 # „É¶„Éº„ÉÜ„Ç£„É™„ÉÜ„Ç£
‚îÇ   ‚îú‚îÄ‚îÄ constants/             # ÂÆöÊï∞
‚îÇ   ‚îî‚îÄ‚îÄ validator/             # „Éê„É™„Éá„Éº„Çø„Éº
‚îú‚îÄ‚îÄ üìÅ migrations/             # „Éá„Éº„Çø„Éô„Éº„Çπ„Éû„Ç§„Ç∞„É¨„Éº„Ç∑„Éß„É≥
‚îú‚îÄ‚îÄ üìÅ docs/                   # Swagger/OpenAPI‰ªïÊßò
‚îú‚îÄ‚îÄ üìÅ scripts/                # ÈÅãÁî®„Çπ„ÇØ„É™„Éó„Éà
‚îú‚îÄ‚îÄ go.mod                     # Go „É¢„Ç∏„É•„Éº„É´
‚îú‚îÄ‚îÄ go.sum                     # ‰æùÂ≠òÈñ¢‰øÇ„Éè„ÉÉ„Ç∑„É•
‚îú‚îÄ‚îÄ Dockerfile                 # DockerË®≠ÂÆö
‚îî‚îÄ‚îÄ docker-compose.yml         # ÈñãÁô∫Áí∞Â¢ÉË®≠ÂÆö
```

## üéØ „Éâ„É°„Ç§„É≥Ë®≠Ë®à

### „Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£Ë®≠Ë®à

#### Book „Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£
```go
// internal/domain/entities/book.go
package entities

import (
    "time"
    "github.com/google/uuid"
)

type Book struct {
    ID              uuid.UUID  `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
    Title           string     `json:"title" gorm:"not null;size:200" validate:"required,min=1,max=200"`
    Author          string     `json:"author" gorm:"not null;size:100" validate:"required,min=1,max=100"`
    Publisher       string     `json:"publisher" gorm:"not null;size:100" validate:"required,min=1,max=100"`
    PublicationDate *time.Time `json:"publication_date" gorm:"type:date"`
    Genre           string     `json:"genre" gorm:"size:50" validate:"omitempty,oneof=„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞ „Éá„Éº„Çø„Éô„Éº„Çπ „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ „Çª„Ç≠„É•„É™„ÉÜ„Ç£ „ÇØ„É©„Ç¶„Éâ AI „Éì„Ç∏„Éç„Çπ „Åù„ÅÆ‰ªñ"`
    PageCount       *int       `json:"page_count" gorm:"check:page_count > 0" validate:"omitempty,min=1"`
    Language        string     `json:"language" gorm:"size:20;default:'Êó•Êú¨Ë™û'" validate:"omitempty,oneof=Êó•Êú¨Ë™û Ëã±Ë™û „Åù„ÅÆ‰ªñ"`
    Owner           string     `json:"owner" gorm:"not null;size:50" validate:"required,min=1,max=50"`
    Description     string     `json:"description" gorm:"type:text" validate:"omitempty,max=1000"`
    Status          BookStatus `json:"status" gorm:"not null;default:'available'" validate:"required,oneof=available borrowed maintenance"`
    CreatedAt       time.Time  `json:"created_at" gorm:"not null"`
    UpdatedAt       time.Time  `json:"updated_at" gorm:"not null"`
    DeletedAt       *time.Time `json:"deleted_at" gorm:"index"`
}

type BookStatus string

const (
    BookStatusAvailable   BookStatus = "available"
    BookStatusBorrowed    BookStatus = "borrowed"
    BookStatusMaintenance BookStatus = "maintenance"
)

// „Éâ„É°„Ç§„É≥„É°„ÇΩ„ÉÉ„Éâ
func (b *Book) IsAvailable() bool {
    return b.Status == BookStatusAvailable && b.DeletedAt == nil
}

func (b *Book) CanBeBorrowed() bool {
    return b.IsAvailable()
}

func (b *Book) Borrow(borrowerID uuid.UUID) error {
    if !b.CanBeBorrowed() {
        return errors.New("book is not available for borrowing")
    }
    b.Status = BookStatusBorrowed
    return nil
}

func (b *Book) Return() error {
    if b.Status != BookStatusBorrowed {
        return errors.New("book is not currently borrowed")
    }
    b.Status = BookStatusAvailable
    return nil
}

func (b *Book) Validate() error {
    validate := validator.New()
    return validate.Struct(b)
}
```

#### User „Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£ÔºàË™çË®ºÂÆüË£ÖÊôÇÔºâ
```go
// internal/domain/entities/user.go
package entities

type User struct {
    ID        uuid.UUID `json:"id" gorm:"type:uuid;primary_key;default:gen_random_uuid()"`
    Email     string    `json:"email" gorm:"unique;not null" validate:"required,email"`
    Username  string    `json:"username" gorm:"unique;not null;size:50" validate:"required,min=3,max=50"`
    Password  string    `json:"-" gorm:"not null" validate:"required,min=8"`
    FirstName string    `json:"first_name" gorm:"size:50" validate:"required,max=50"`
    LastName  string    `json:"last_name" gorm:"size:50" validate:"required,max=50"`
    Role      UserRole  `json:"role" gorm:"not null;default:'user'" validate:"required,oneof=admin librarian user"`
    IsActive  bool      `json:"is_active" gorm:"not null;default:true"`
    CreatedAt time.Time `json:"created_at" gorm:"not null"`
    UpdatedAt time.Time `json:"updated_at" gorm:"not null"`
}

type UserRole string

const (
    UserRoleAdmin     UserRole = "admin"
    UserRoleLibrarian UserRole = "librarian"
    UserRoleUser      UserRole = "user"
)

func (u *User) HasPermission(action string, resource string) bool {
    permissions := rolePermissions[u.Role]
    return permissions.Has(action, resource)
}
```

### „É™„Éù„Ç∏„Éà„É™„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ
```go
// internal/domain/repositories/book_repository.go
package repositories

import (
    "context"
    "github.com/google/uuid"
    "tech-lib/internal/domain/entities"
)

type BookRepository interface {
    // Âü∫Êú¨CRUDÊìç‰Ωú
    Create(ctx context.Context, book *entities.Book) error
    GetByID(ctx context.Context, id uuid.UUID) (*entities.Book, error)
    Update(ctx context.Context, book *entities.Book) error
    Delete(ctx context.Context, id uuid.UUID) error
    
    // Ê§úÁ¥¢„Éª„Éï„Ç£„É´„Çø„É™„É≥„Ç∞
    List(ctx context.Context, filter BookFilter) ([]*entities.Book, error)
    Count(ctx context.Context, filter BookFilter) (int64, error)
    Search(ctx context.Context, query string, filter BookFilter) ([]*entities.Book, error)
    
    // „Éì„Ç∏„Éç„ÇπÂõ∫ÊúâÊìç‰Ωú
    GetByStatus(ctx context.Context, status entities.BookStatus) ([]*entities.Book, error)
    GetByOwner(ctx context.Context, owner string) ([]*entities.Book, error)
    GetExpiringSoon(ctx context.Context, days int) ([]*entities.Book, error)
}

type BookFilter struct {
    Limit      int                    `json:"limit"`
    Offset     int                    `json:"offset"`
    SortBy     string                 `json:"sort_by"`
    SortOrder  string                 `json:"sort_order"`
    Genre      string                 `json:"genre"`
    Language   string                 `json:"language"`
    Status     entities.BookStatus    `json:"status"`
    Owner      string                 `json:"owner"`
    DateFrom   *time.Time            `json:"date_from"`
    DateTo     *time.Time            `json:"date_to"`
}
```

### „Éâ„É°„Ç§„É≥„Çµ„Éº„Éì„Çπ
```go
// internal/domain/services/book_service.go
package services

type BookDomainService struct {
    bookRepo repositories.BookRepository
    logger   logger.Logger
}

func NewBookDomainService(bookRepo repositories.BookRepository, logger logger.Logger) *BookDomainService {
    return &BookDomainService{
        bookRepo: bookRepo,
        logger:   logger,
    }
}

// ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
func (s *BookDomainService) CheckDuplicate(ctx context.Context, title, author string) (bool, error) {
    books, err := s.bookRepo.Search(ctx, fmt.Sprintf("%s %s", title, author), BookFilter{Limit: 1})
    if err != nil {
        return false, err
    }
    
    for _, book := range books {
        if strings.EqualFold(book.Title, title) && strings.EqualFold(book.Author, author) {
            return true, nil
        }
    }
    
    return false, nil
}

// Ë≤∏Âá∫ÂèØËÉΩÊÄß„ÉÅ„Çß„ÉÉ„ÇØ
func (s *BookDomainService) CanBorrow(ctx context.Context, bookID uuid.UUID, userID uuid.UUID) (bool, error) {
    book, err := s.bookRepo.GetByID(ctx, bookID)
    if err != nil {
        return false, err
    }
    
    if !book.CanBeBorrowed() {
        return false, nil
    }
    
    // „É¶„Éº„Ç∂„Éº„ÅÆË≤∏Âá∫‰∏äÈôê„ÉÅ„Çß„ÉÉ„ÇØÔºàÂÆüË£ÖÊôÇÔºâ
    // userBorrowedCount, err := s.borrowRepo.CountByUser(ctx, userID)
    // if userBorrowedCount >= MaxBorrowLimit {
    //     return false, nil
    // }
    
    return true, nil
}
```

## üîß „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥Â±§Ë®≠Ë®à

### „É¶„Éº„Çπ„Ç±„Éº„ÇπÂÆüË£Ö
```go
// internal/application/usecases/book_usecase.go
package usecases

type BookUseCase struct {
    bookRepo    repositories.BookRepository
    bookService services.BookDomainService
    logger      logger.Logger
    cache       cache.Cache
}

func NewBookUseCase(
    bookRepo repositories.BookRepository,
    bookService services.BookDomainService,
    logger logger.Logger,
    cache cache.Cache,
) *BookUseCase {
    return &BookUseCase{
        bookRepo:    bookRepo,
        bookService: bookService,
        logger:      logger,
        cache:       cache,
    }
}

func (uc *BookUseCase) CreateBook(ctx context.Context, req dto.CreateBookRequest) (*dto.BookResponse, error) {
    // „Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    if err := req.Validate(); err != nil {
        return nil, errors.NewValidationError("invalid request", err)
    }
    
    // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
    isDuplicate, err := uc.bookService.CheckDuplicate(ctx, req.Title, req.Author)
    if err != nil {
        uc.logger.Error("failed to check duplicate", "error", err)
        return nil, errors.NewInternalError("duplicate check failed")
    }
    if isDuplicate {
        return nil, errors.NewBusinessError("book already exists")
    }
    
    // „Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£‰ΩúÊàê
    book := &entities.Book{
        Title:           req.Title,
        Author:          req.Author,
        Publisher:       req.Publisher,
        PublicationDate: req.PublicationDate,
        Genre:           req.Genre,
        PageCount:       req.PageCount,
        Language:        req.Language,
        Owner:           req.Owner,
        Description:     req.Description,
        Status:          entities.BookStatusAvailable,
    }
    
    // „Éâ„É°„Ç§„É≥„Éê„É™„Éá„Éº„Ç∑„Éß„É≥
    if err := book.Validate(); err != nil {
        return nil, errors.NewValidationError("invalid book data", err)
    }
    
    // Ê∞∏Á∂öÂåñ
    if err := uc.bookRepo.Create(ctx, book); err != nil {
        uc.logger.Error("failed to create book", "error", err)
        return nil, errors.NewInternalError("book creation failed")
    }
    
    // „Ç≠„É£„ÉÉ„Ç∑„É•ÁÑ°ÂäπÂåñ
    uc.cache.Delete(ctx, "books:list")
    
    // „É¨„Çπ„Éù„É≥„Çπ‰ΩúÊàê
    response := dto.BookResponse{
        ID:              book.ID,
        Title:           book.Title,
        Author:          book.Author,
        Publisher:       book.Publisher,
        PublicationDate: book.PublicationDate,
        Genre:           book.Genre,
        PageCount:       book.PageCount,
        Language:        book.Language,
        Owner:           book.Owner,
        Description:     book.Description,
        Status:          string(book.Status),
        CreatedAt:       book.CreatedAt,
        UpdatedAt:       book.UpdatedAt,
    }
    
    uc.logger.Info("book created successfully", "book_id", book.ID)
    return &response, nil
}

func (uc *BookUseCase) GetBooks(ctx context.Context, req dto.GetBooksRequest) (*dto.GetBooksResponse, error) {
    // „Ç≠„É£„ÉÉ„Ç∑„É•„ÉÅ„Çß„ÉÉ„ÇØ
    cacheKey := fmt.Sprintf("books:list:%s", req.Hash())
    if cached, err := uc.cache.Get(ctx, cacheKey); err == nil {
        var response dto.GetBooksResponse
        if err := json.Unmarshal(cached, &response); err == nil {
            return &response, nil
        }
    }
    
    // „Éï„Ç£„É´„Çø„Éº‰ΩúÊàê
    filter := repositories.BookFilter{
        Limit:     req.Limit,
        Offset:    req.Offset,
        SortBy:    req.SortBy,
        SortOrder: req.SortOrder,
        Genre:     req.Genre,
        Language:  req.Language,
        Status:    entities.BookStatus(req.Status),
    }
    
    // „Éá„Éº„ÇøÂèñÂæó
    books, err := uc.bookRepo.List(ctx, filter)
    if err != nil {
        uc.logger.Error("failed to get books", "error", err)
        return nil, errors.NewInternalError("books retrieval failed")
    }
    
    // Á∑è‰ª∂Êï∞ÂèñÂæó
    total, err := uc.bookRepo.Count(ctx, filter)
    if err != nil {
        uc.logger.Error("failed to count books", "error", err)
        return nil, errors.NewInternalError("books count failed")
    }
    
    // „É¨„Çπ„Éù„É≥„Çπ‰ΩúÊàê
    response := &dto.GetBooksResponse{
        Books: make([]dto.BookResponse, len(books)),
        Pagination: dto.PaginationResponse{
            CurrentPage:  (req.Offset / req.Limit) + 1,
            TotalPages:   int(math.Ceil(float64(total) / float64(req.Limit))),
            TotalItems:   int(total),
            ItemsPerPage: req.Limit,
        },
    }
    
    for i, book := range books {
        response.Books[i] = dto.BookResponse{
            ID:              book.ID,
            Title:           book.Title,
            Author:          book.Author,
            Publisher:       book.Publisher,
            PublicationDate: book.PublicationDate,
            Genre:           book.Genre,
            PageCount:       book.PageCount,
            Language:        book.Language,
            Owner:           book.Owner,
            Description:     book.Description,
            Status:          string(book.Status),
            CreatedAt:       book.CreatedAt,
            UpdatedAt:       book.UpdatedAt,
        }
    }
    
    // „Ç≠„É£„ÉÉ„Ç∑„É•‰øùÂ≠òÔºà5ÂàÜÈñìÔºâ
    if data, err := json.Marshal(response); err == nil {
        uc.cache.Set(ctx, cacheKey, data, 5*time.Minute)
    }
    
    return response, nil
}
```

### DTOË®≠Ë®à
```go
// internal/application/dto/book_dto.go
package dto

type CreateBookRequest struct {
    Title           string     `json:"title" validate:"required,min=1,max=200"`
    Author          string     `json:"author" validate:"required,min=1,max=100"`
    Publisher       string     `json:"publisher" validate:"required,min=1,max=100"`
    PublicationDate *time.Time `json:"publication_date"`
    Genre           string     `json:"genre" validate:"omitempty,oneof=„Éó„É≠„Ç∞„É©„Éü„É≥„Ç∞ „Éá„Éº„Çø„Éô„Éº„Çπ „Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ „Çª„Ç≠„É•„É™„ÉÜ„Ç£ „ÇØ„É©„Ç¶„Éâ AI „Éì„Ç∏„Éç„Çπ „Åù„ÅÆ‰ªñ"`
    PageCount       *int       `json:"page_count" validate:"omitempty,min=1"`
    Language        string     `json:"language" validate:"omitempty,oneof=Êó•Êú¨Ë™û Ëã±Ë™û „Åù„ÅÆ‰ªñ"`
    Owner           string     `json:"owner" validate:"required,min=1,max=50"`
    Description     string     `json:"description" validate:"omitempty,max=1000"`
}

func (r *CreateBookRequest) Validate() error {
    validate := validator.New()
    return validate.Struct(r)
}

type GetBooksRequest struct {
    Limit     int    `json:"limit" form:"limit" validate:"omitempty,min=1,max=100"`
    Offset    int    `json:"offset" form:"offset" validate:"omitempty,min=0"`
    SortBy    string `json:"sort_by" form:"sort_by" validate:"omitempty,oneof=title author publisher publication_date created_at"`
    SortOrder string `json:"sort_order" form:"sort_order" validate:"omitempty,oneof=asc desc"`
    Search    string `json:"search" form:"search" validate:"omitempty,max=100"`
    Genre     string `json:"genre" form:"genre"`
    Language  string `json:"language" form:"language"`
    Status    string `json:"status" form:"status"`
}

func (r *GetBooksRequest) Hash() string {
    h := sha256.New()
    h.Write([]byte(fmt.Sprintf("%+v", r)))
    return hex.EncodeToString(h.Sum(nil))
}

type BookResponse struct {
    ID              uuid.UUID  `json:"id"`
    Title           string     `json:"title"`
    Author          string     `json:"author"`
    Publisher       string     `json:"publisher"`
    PublicationDate *time.Time `json:"publication_date"`
    Genre           string     `json:"genre"`
    PageCount       *int       `json:"page_count"`
    Language        string     `json:"language"`
    Owner           string     `json:"owner"`
    Description     string     `json:"description"`
    Status          string     `json:"status"`
    CreatedAt       time.Time  `json:"created_at"`
    UpdatedAt       time.Time  `json:"updated_at"`
}

type GetBooksResponse struct {
    Books      []BookResponse       `json:"books"`
    Pagination PaginationResponse   `json:"pagination"`
}

type PaginationResponse struct {
    CurrentPage  int `json:"current_page"`
    TotalPages   int `json:"total_pages"`
    TotalItems   int `json:"total_items"`
    ItemsPerPage int `json:"items_per_page"`
}
```

## üåê APIÂ±§Ë®≠Ë®à

### „Éè„É≥„Éâ„É©„ÉºÂÆüË£Ö
```go
// internal/api/handlers/book_handler.go
package handlers

type BookHandler struct {
    bookUseCase usecases.BookUseCase
    logger      logger.Logger
}

func NewBookHandler(bookUseCase usecases.BookUseCase, logger logger.Logger) *BookHandler {
    return &BookHandler{
        bookUseCase: bookUseCase,
        logger:      logger,
    }
}

func (h *BookHandler) CreateBook(c *gin.Context) {
    var req dto.CreateBookRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        h.logger.Warn("invalid request body", "error", err)
        responses.ErrorResponse(c, http.StatusBadRequest, "INVALID_REQUEST", "„É™„ÇØ„Ç®„Çπ„Éà„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì", err.Error())
        return
    }
    
    book, err := h.bookUseCase.CreateBook(c.Request.Context(), req)
    if err != nil {
        h.handleError(c, err)
        return
    }
    
    responses.SuccessResponse(c, http.StatusCreated, book, "Êõ∏Á±ç„ÇíÁôªÈå≤„Åó„Åæ„Åó„Åü")
}

func (h *BookHandler) GetBooks(c *gin.Context) {
    var req dto.GetBooksRequest
    if err := c.ShouldBindQuery(&req); err != nil {
        h.logger.Warn("invalid query parameters", "error", err)
        responses.ErrorResponse(c, http.StatusBadRequest, "INVALID_PARAMS", "„Éë„É©„É°„Éº„Çø„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„Çì", err.Error())
        return
    }
    
    // „Éá„Éï„Ç©„É´„ÉàÂÄ§Ë®≠ÂÆö
    if req.Limit == 0 {
        req.Limit = 20
    }
    if req.SortBy == "" {
        req.SortBy = "created_at"
    }
    if req.SortOrder == "" {
        req.SortOrder = "desc"
    }
    
    books, err := h.bookUseCase.GetBooks(c.Request.Context(), req)
    if err != nil {
        h.handleError(c, err)
        return
    }
    
    responses.SuccessResponse(c, http.StatusOK, books, "Êõ∏Á±ç‰∏ÄË¶ß„ÇíÂèñÂæó„Åó„Åæ„Åó„Åü")
}

func (h *BookHandler) handleError(c *gin.Context, err error) {
    switch e := err.(type) {
    case *errors.ValidationError:
        responses.ErrorResponse(c, http.StatusBadRequest, "VALIDATION_ERROR", e.Message, e.Details)
    case *errors.BusinessError:
        responses.ErrorResponse(c, http.StatusConflict, "BUSINESS_ERROR", e.Message, "")
    case *errors.NotFoundError:
        responses.ErrorResponse(c, http.StatusNotFound, "NOT_FOUND", e.Message, "")
    default:
        h.logger.Error("internal server error", "error", err)
        responses.ErrorResponse(c, http.StatusInternalServerError, "INTERNAL_ERROR", "ÂÜÖÈÉ®„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü", "")
    }
}
```

### „É¨„Çπ„Éù„É≥„ÇπÊ®ôÊ∫ñÂåñ
```go
// internal/api/responses/response.go
package responses

type APIResponse struct {
    Success   bool        `json:"success"`
    Data      interface{} `json:"data,omitempty"`
    Error     *ErrorInfo  `json:"error,omitempty"`
    Message   string      `json:"message,omitempty"`
    Timestamp time.Time   `json:"timestamp"`
}

type ErrorInfo struct {
    Code    string `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
}

func SuccessResponse(c *gin.Context, status int, data interface{}, message string) {
    c.JSON(status, APIResponse{
        Success:   true,
        Data:      data,
        Message:   message,
        Timestamp: time.Now(),
    })
}

func ErrorResponse(c *gin.Context, status int, code, message, details string) {
    c.JSON(status, APIResponse{
        Success: false,
        Error: &ErrorInfo{
            Code:    code,
            Message: message,
            Details: details,
        },
        Timestamp: time.Now(),
    })
}
```

### „Éü„Éâ„É´„Ç¶„Çß„Ç¢Ë®≠Ë®à
```go
// internal/api/middleware/cors.go
func CORS() gin.HandlerFunc {
    return gin.HandlerFunc(func(c *gin.Context) {
        origin := c.Request.Header.Get("Origin")
        
        // Ë®±ÂèØ„Åï„Çå„Åü„Ç™„É™„Ç∏„É≥„Åã„ÉÅ„Çß„ÉÉ„ÇØ
        if isAllowedOrigin(origin) {
            c.Writer.Header().Set("Access-Control-Allow-Origin", origin)
        }
        
        c.Writer.Header().Set("Access-Control-Allow-Credentials", "true")
        c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token, Authorization, accept, origin, Cache-Control, X-Requested-With")
        c.Writer.Header().Set("Access-Control-Allow-Methods", "POST, OPTIONS, GET, PUT, DELETE")

        if c.Request.Method == "OPTIONS" {
            c.AbortWithStatus(204)
            return
        }

        c.Next()
    })
}

// internal/api/middleware/rate_limit.go
func RateLimit() gin.HandlerFunc {
    store := memory.NewStore()
    return ratelimit.RateLimiter(store, &ratelimit.Options{
        ErrorHandler: func(c *gin.Context, info ratelimit.Info) {
            c.JSON(http.StatusTooManyRequests, gin.H{
                "error": "Too many requests",
                "retry_after": info.ResetTime,
            })
        },
        KeyFunc: func(c *gin.Context) string {
            return c.ClientIP()
        },
    })
}

// internal/api/middleware/logger.go
func Logger(logger logger.Logger) gin.HandlerFunc {
    return gin.LoggerWithFormatter(func(param gin.LogFormatterParams) string {
        logger.Info("HTTP Request",
            "method", param.Method,
            "path", param.Path,
            "status", param.StatusCode,
            "latency", param.Latency,
            "ip", param.ClientIP,
            "user_agent", param.Request.UserAgent(),
        )
        return ""
    })
}
```

## üóÑÔ∏è „Ç§„É≥„Éï„É©Â±§Ë®≠Ë®à

### „Éá„Éº„Çø„Éô„Éº„ÇπÂÆüË£Ö
```go
// internal/infrastructure/database/postgres.go
package database

type PostgresDB struct {
    db     *gorm.DB
    logger logger.Logger
}

func NewPostgresDB(config Config, logger logger.Logger) (*PostgresDB, error) {
    dsn := fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=%s TimeZone=Asia/Tokyo",
        config.Host, config.User, config.Password, config.DBName, config.Port, config.SSLMode)
    
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
        Logger: gormLogger.New(
            log.New(os.Stdout, "\r\n", log.LstdFlags),
            gormLogger.Config{
                SlowThreshold: time.Second,
                LogLevel:      gormLogger.Info,
                Colorful:      true,
            },
        ),
        NamingStrategy: schema.NamingStrategy{
            SingularTable: false,
            NoLowerCase:   false,
        },
    })
    
    if err != nil {
        return nil, fmt.Errorf("failed to connect to database: %w", err)
    }
    
    // „Ç≥„Éç„ÇØ„Ç∑„Éß„É≥„Éó„Éº„É´Ë®≠ÂÆö
    sqlDB, err := db.DB()
    if err != nil {
        return nil, fmt.Errorf("failed to get sql.DB: %w", err)
    }
    
    sqlDB.SetMaxIdleConns(10)
    sqlDB.SetMaxOpenConns(100)
    sqlDB.SetConnMaxLifetime(time.Hour)
    
    return &PostgresDB{db: db, logger: logger}, nil
}

func (p *PostgresDB) Migrate() error {
    return p.db.AutoMigrate(
        &entities.Book{},
        &entities.User{},
        // ‰ªñ„ÅÆ„Ç®„É≥„ÉÜ„Ç£„ÉÜ„Ç£
    )
}
```

### „É™„Éù„Ç∏„Éà„É™ÂÆüË£Ö
```go
// internal/infrastructure/repositories/book_repository_impl.go
package repositories

type BookRepositoryImpl struct {
    db     *gorm.DB
    logger logger.Logger
}

func NewBookRepositoryImpl(db *gorm.DB, logger logger.Logger) repositories.BookRepository {
    return &BookRepositoryImpl{db: db, logger: logger}
}

func (r *BookRepositoryImpl) Create(ctx context.Context, book *entities.Book) error {
    if err := r.db.WithContext(ctx).Create(book).Error; err != nil {
        r.logger.Error("failed to create book", "error", err)
        return fmt.Errorf("create book failed: %w", err)
    }
    return nil
}

func (r *BookRepositoryImpl) List(ctx context.Context, filter repositories.BookFilter) ([]*entities.Book, error) {
    var books []*entities.Book
    
    query := r.db.WithContext(ctx).Model(&entities.Book{})
    
    // „Éï„Ç£„É´„Çø„É™„É≥„Ç∞
    if filter.Genre != "" {
        query = query.Where("genre = ?", filter.Genre)
    }
    if filter.Language != "" {
        query = query.Where("language = ?", filter.Language)
    }
    if filter.Status != "" {
        query = query.Where("status = ?", filter.Status)
    }
    if filter.Owner != "" {
        query = query.Where("owner ILIKE ?", "%"+filter.Owner+"%")
    }
    if filter.DateFrom != nil {
        query = query.Where("created_at >= ?", filter.DateFrom)
    }
    if filter.DateTo != nil {
        query = query.Where("created_at <= ?", filter.DateTo)
    }
    
    // „ÇΩ„Éº„Éà
    if filter.SortBy != "" {
        order := filter.SortBy
        if filter.SortOrder == "desc" {
            order += " DESC"
        }
        query = query.Order(order)
    }
    
    // „Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥
    if filter.Limit > 0 {
        query = query.Limit(filter.Limit)
    }
    if filter.Offset > 0 {
        query = query.Offset(filter.Offset)
    }
    
    if err := query.Find(&books).Error; err != nil {
        r.logger.Error("failed to list books", "error", err)
        return nil, fmt.Errorf("list books failed: %w", err)
    }
    
    return books, nil
}
```

### „Ç≠„É£„ÉÉ„Ç∑„É•ÂÆüË£Ö
```go
// internal/infrastructure/cache/redis.go
package cache

type RedisCache struct {
    client *redis.Client
    logger logger.Logger
}

func NewRedisCache(addr, password string, db int, logger logger.Logger) *RedisCache {
    rdb := redis.NewClient(&redis.Options{
        Addr:     addr,
        Password: password,
        DB:       db,
    })
    
    return &RedisCache{client: rdb, logger: logger}
}

func (r *RedisCache) Set(ctx context.Context, key string, value []byte, expiration time.Duration) error {
    err := r.client.Set(ctx, key, value, expiration).Err()
    if err != nil {
        r.logger.Error("failed to set cache", "key", key, "error", err)
        return err
    }
    return nil
}

func (r *RedisCache) Get(ctx context.Context, key string) ([]byte, error) {
    val, err := r.client.Get(ctx, key).Result()
    if err != nil {
        if err == redis.Nil {
            return nil, errors.ErrCacheNotFound
        }
        r.logger.Error("failed to get cache", "key", key, "error", err)
        return nil, err
    }
    return []byte(val), nil
}
```

## üìä „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊúÄÈÅ©Âåñ

### „Éá„Éº„Çø„Éô„Éº„ÇπÊúÄÈÅ©Âåñ
```go
// „Éá„Éº„Çø„Éô„Éº„Çπ„Ç§„É≥„Éá„ÉÉ„ÇØ„ÇπÊúÄÈÅ©Âåñ
func (r *BookRepositoryImpl) CreateIndexes() error {
    indexes := []string{
        "CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_books_title ON books USING gin(to_tsvector('japanese', title))",
        "CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_books_author ON books(author)",
        "CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_books_genre ON books(genre)",
        "CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_books_status ON books(status)",
        "CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_books_created_at ON books(created_at DESC)",
        "CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_books_owner ON books(owner)",
    }
    
    for _, idx := range indexes {
        if err := r.db.Exec(idx).Error; err != nil {
            r.logger.Error("failed to create index", "sql", idx, "error", err)
            return err
        }
    }
    
    return nil
}

// „ÇØ„Ç®„É™ÊúÄÈÅ©Âåñ
func (r *BookRepositoryImpl) SearchOptimized(ctx context.Context, query string, filter repositories.BookFilter) ([]*entities.Book, error) {
    var books []*entities.Book
    
    // ÂÖ®ÊñáÊ§úÁ¥¢„ÇØ„Ç®„É™
    searchQuery := `
        SELECT * FROM books 
        WHERE to_tsvector('japanese', title || ' ' || author || ' ' || description) 
        @@ plainto_tsquery('japanese', ?)
        AND deleted_at IS NULL
    `
    
    args := []interface{}{query}
    
    // „Éï„Ç£„É´„Çø„ÉºÊù°‰ª∂ËøΩÂä†
    if filter.Genre != "" {
        searchQuery += " AND genre = ?"
        args = append(args, filter.Genre)
    }
    
    // „ÇΩ„Éº„Éà„Éª„Éö„Éº„Ç∏„Éç„Éº„Ç∑„Éß„É≥
    searchQuery += fmt.Sprintf(" ORDER BY %s %s LIMIT ? OFFSET ?", 
        filter.SortBy, filter.SortOrder)
    args = append(args, filter.Limit, filter.Offset)
    
    if err := r.db.WithContext(ctx).Raw(searchQuery, args...).Scan(&books).Error; err != nil {
        return nil, err
    }
    
    return books, nil
}
```

### ‰∏¶Ë°åÂá¶ÁêÜÊúÄÈÅ©Âåñ
```go
// ‰∏¶Ë°åÂá¶ÁêÜ„Å´„Çà„Çã„Éê„ÉÉ„ÉÅÊìç‰Ωú
func (uc *BookUseCase) BulkCreateBooks(ctx context.Context, requests []dto.CreateBookRequest) ([]dto.BookResponse, []error) {
    const batchSize = 10
    const maxWorkers = 5
    
    results := make([]dto.BookResponse, len(requests))
    errors := make([]error, len(requests))
    
    // „ÉØ„Éº„Ç´„Éº„Éó„Éº„É´‰ΩúÊàê
    jobs := make(chan BatchJob, len(requests))
    wg := sync.WaitGroup{}
    
    // „ÉØ„Éº„Ç´„ÉºËµ∑Âãï
    for i := 0; i < maxWorkers; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            for job := range jobs {
                result, err := uc.CreateBook(ctx, job.Request)
                if err != nil {
                    errors[job.Index] = err
                } else {
                    results[job.Index] = *result
                }
            }
        }()
    }
    
    // „Ç∏„Éß„ÉñÈÄÅ‰ø°
    for i, req := range requests {
        jobs <- BatchJob{Index: i, Request: req}
    }
    close(jobs)
    
    wg.Wait()
    return results, errors
}
```

## üß™ „ÉÜ„Çπ„ÉàË®≠Ë®à

### „É¶„Éã„ÉÉ„Éà„ÉÜ„Çπ„Éà
```go
// internal/domain/entities/book_test.go
func TestBook_CanBeBorrowed(t *testing.T) {
    tests := []struct {
        name     string
        book     entities.Book
        expected bool
    }{
        {
            name: "available book can be borrowed",
            book: entities.Book{
                Status:    entities.BookStatusAvailable,
                DeletedAt: nil,
            },
            expected: true,
        },
        {
            name: "borrowed book cannot be borrowed",
            book: entities.Book{
                Status:    entities.BookStatusBorrowed,
                DeletedAt: nil,
            },
            expected: false,
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            assert.Equal(t, tt.expected, tt.book.CanBeBorrowed())
        })
    }
}
```

### Áµ±Âêà„ÉÜ„Çπ„Éà
```go
// tests/integration/book_api_test.go
func TestBookAPI_CreateBook(t *testing.T) {
    // „ÉÜ„Çπ„ÉàÁî®„Éá„Éº„Çø„Éô„Éº„ÇπË®≠ÂÆö
    testDB := setupTestDB(t)
    defer teardownTestDB(t, testDB)
    
    // „ÉÜ„Çπ„ÉàÁî®„Çµ„Éº„Éê„ÉºËµ∑Âãï
    server := setupTestServer(t, testDB)
    defer server.Close()
    
    // „ÉÜ„Çπ„Éà„Ç±„Éº„Çπ
    testCases := []struct {
        name           string
        payload        dto.CreateBookRequest
        expectedStatus int
        expectedError  string
    }{
        {
            name: "valid book creation",
            payload: dto.CreateBookRequest{
                Title:     "Test Book",
                Author:    "Test Author",
                Publisher: "Test Publisher",
                Owner:     "Test Owner",
            },
            expectedStatus: http.StatusCreated,
        },
        {
            name: "missing required fields",
            payload: dto.CreateBookRequest{
                Title: "Test Book",
                // Author missing
            },
            expectedStatus: http.StatusBadRequest,
            expectedError:  "VALIDATION_ERROR",
        },
    }
    
    for _, tc := range testCases {
        t.Run(tc.name, func(t *testing.T) {
            body, _ := json.Marshal(tc.payload)
            req := httptest.NewRequest("POST", "/api/books", bytes.NewBuffer(body))
            req.Header.Set("Content-Type", "application/json")
            
            resp := httptest.NewRecorder()
            server.Handler.ServeHTTP(resp, req)
            
            assert.Equal(t, tc.expectedStatus, resp.Code)
            
            if tc.expectedError != "" {
                var response responses.APIResponse
                json.Unmarshal(resp.Body.Bytes(), &response)
                assert.Equal(t, tc.expectedError, response.Error.Code)
            }
        })
    }
}
```

---

**ÊúÄÁµÇÊõ¥Êñ∞**: 2025Âπ¥6Êúà15Êó•  
**ÂØæË±°„Éê„Éº„Ç∏„Éß„É≥**: Go 1.23+, Gin 1.9+  
**„Çπ„ÉÜ„Éº„Çø„Çπ**: ÂÆüË£Ö‰∏≠